{"pages":[{"title":"我的朋友们","permalink":"https://xaoxuu.com/blog/friends/index.html","text":"各位大佬想交换友链的话可以在下方留言，必须要有名称、头像链接、和至少一个标签哦～名称： xaoxuu’s blog头像： https://cdn.jsdelivr.net/gh/xaoxuu/assets@master/avatar/avatar.png网址： https://xaoxuu.com/blog/标签： iOS分组和标签不合适的话可以留言或者发邮件私聊我进行更改。头像尺寸是64px，3倍精细度就足够了，也就是192px，如果文件体积太大可以压缩一下。"},{"title":"所有分类","permalink":"https://xaoxuu.com/blog/categories/index.html","text":""},{"title":"所有标签","permalink":"https://xaoxuu.com/blog/tags/index.html","text":""}],"posts":[{"title":"使用 NoticeBoard 迅捷而优雅地发布通知","permalink":"https://xaoxuu.com/blog/2018-07-30-noticeboard/","text":"Android 有原生的 SnackBar ，iOS 没有与之相似的原生控件，GitHub 上好像也没有找到特别好用的开源库。既然在 Android 平台上能够作为原生控件存在，足以说明这种需求不算太不小众，在 iOS 端，类似的需求可能被 UIAlertController、MBProgressHUD 来替代，但是他们都需要打断用户当前正在进行的事情，体验很不好。GitHub 上有一个开源库 NoticeBar ，模仿QQ的实现效果，虽然有200+的Star，个人感觉 UI 和可定制性都不够理想，于是自己写了一个模仿系统原生通知样式的易于定制的 NoticeBoard，下面请看截图和演示效果：screenshotvideoNoticeBoard 的功能定位是应用内消息控件，相对于系统通知，它显而易见的优点是：简单易用、可定制性强，相对于原生的 UIAlertController 和开源的 MBProgressHUD ，它的优点是专为这种特定场景而生：只需要告诉用户发生了什么，不必立即处理，或者可以 稍后再处理。演示如何使用强烈建议感兴趣的朋友亲自下载 源码 运行 Example 项目，因为项目中提供了大量的演示程序，通过这些演示你可以清楚地了解到使用方法及其效果。导入 NoticeBoard如果要在工程项目中使用NoticeBoard，需要在 Podfile 中添加这一行：1pod 'NoticeBoard'快速 post 示例最简单的，你可以直接发送一条 “Hello World!” ：1NoticeBoard.post(\"Hello World!\")用户可以像移除系统原生通知那样拖拽一条通知往上方移动丢出屏幕外，如果你希望消息自动消失，需要传入消息的持续时间：1NoticeBoard.post(\"Hello World!\", duration: 2)或者直接发出一条警告消息：1NoticeBoard.post(.warning, title: \"电量过低\", message: \"电量不足10%，请及时给设备充电。\", duration: 10)标准 post 步骤123456// 创建noticelet notice = Notice.init(title: \"标题\", icon: UIImage.init(named: \"alert-\"), body: \"正文\")// 设置notice...// 发布notice NoticeBoard.shared.post(notice, duration: 2)设置notice123456789// 按钮事件notice.actionButtonDidTapped &#123; (notice, btn) in print(\"点击了'→'按钮\")&#125;// 设置颜色主题notice.themeColor = .init(red: 0.2, green: 0.3, blue: 0.4, alpha: 1)// 模糊背景（暂时只支持iOS11，在之前的系统会自动改为纯色背景），和纯色背景可以同时使用notice.blurEffectStyle = .light还有更多设置，例如：警示（alert）、禁止被用户通过手势移除、设置正文最大高度等，详见 文档 。移除通知1234// 移除某个通知NoticeBoard.shared.remove(notice)// 清空NoticeBoard.shared.clean()post 进度设置任意一条 notice 实例的 progress 属性，即时生效。123456// 进度为0notice.progress = 0// 进度为50%notice.progress = 0.5// 进度为100%notice.progress = 1post 自定义 viewNoticeBoard 开源库提供了极大的自由度，你可以只享受 NoticeBoard 提供的对 Notice 管理策略（post、remove、手势、过渡动画），而不使用现有的 Notice 的默认 UI，做法就是创建一个空白的 Notice 实例，添加自定义的视图。123let notice = Notice()notice.rootViewController?.view.addSubview(myView)NoticeBoard.post(notice)根据这一特性，你可以继承 Notice ，重写初始化方法， 从而创建符合公司内部 UI 要求的 Notice 。多个通知的布局如果同一时间需要存在多个通知，可以根据使用场景选择不同的布局方式：12345678910111213141516171819// 平铺，默认（所有通知都可见，但是通知过多会超出屏幕）NoticeBoard.shared.layoutStyle = .tileNoticeBoard.shared.post(notice, duration: 2)// 取代旧的通知（旧的采用fade动画淡出）NoticeBoard.shared.layoutStyle = .replaceNoticeBoard.shared.post(notice, duration: 2)// 移除旧的通知（旧的采用moveout动画移出屏幕）NoticeBoard.shared.layoutStyle = .removeNoticeBoard.shared.post(notice, duration: 2)// 覆盖在旧的通知上层（切勿堆积过多）NoticeBoard.shared.layoutStyle = .overlayNoticeBoard.shared.post(notice, duration: 2)// 堆叠（最新的通知会遮挡旧的通知）NoticeBoard.shared.layoutStyle = .stackNoticeBoard.shared.post(notice, duration: 2)设置Level默认提供了四种level：12345// case low = 4000// case normal = 4100// case high = 4200// case veryHigh = 4300notice.level = .normal也可以直接设置任意数值：1notice.windowLevel = 1000在Swift和Objective-C中使用NoticeBoard使用Swift4.1语言编写，如需在Objective-C项目中使用，可以采用Objective-C和Swift混编的方式。源码和文档链接如果你觉得有用，请前往GitHub点个赞支持。项目源码：https://github.com/xaoxuu/NoticeBoard开发文档：https://xaoxuu.com/wiki/noticeboard"},{"title":"整理混乱不堪的各国语言翻译","permalink":"https://xaoxuu.com/blog/2017-12-25-merge-localizable-strings/","text":"linksmart项目截止目前已经支持了17个国家的语言，从诞生到现在也已经经历了很多程序员的修改和维护，代码已经变得十分混乱。因为公司一直在接新的定制项目，所以也没有时间进行一次彻底的重构，只能在维护某方面的BUG的时候，对相关代码进行局部重构。现在的情况是：同一个文本有些语言有翻译，有些语言没有翻译。有些需要使用缩进的地方，由于某种原因，并没有使用UIEdgeInsets进行缩进，而是在文本前后加空格。(⊙﹏⊙)b整理思路首先必须得找出一种合适的方法维护这些Localizable.strings，在Excel里做一个总表，增加语言的时候，可以直接把英文的一列发给客户进行翻译。最大的优势是：随时可以用脚本把Excel里的所有语言导出成项目支持的Localizable.strings文件，极大提高效率。1. 补全使用genstrings命令将所有.m文件中的LocalizedString文本生成Localizable.strings。打开终端，进入项目根目录，执行以下命令：1find ./ -name \"*.m\" -print0 | xargs -0 genstrings -o en.lproj生成的这一份文件只包含所有.m文件中的国际化字符串，并不包含plist和xib中的字符串。接下来只要把这一份和原来的所有翻译合并起来去重，就得到一份最全的key。2. 合并去重我尝试过直接读取Localizable.strings文件，但提示编码错误，就暂时copy到txt文件中进行处理。合并的Demo：https://github.com/xaoxuu/LocalizedTool-iOS3. 导入Excel接下来的步骤工作量有点大，就是重新把那些翻译导入Excel中，补全缺少的那些翻译。导入Excel和从Excel导出为Localizable.strings的方法在这里：https://xaoxuu.com/blog/2017-03-08-ios-localizable-string"},{"title":"iOS 推迟而不重复执行函数","permalink":"https://xaoxuu.com/blog/2017-11-09-gcd-delay/","text":"如果你想推迟执行一段代码，使用dispatch_after函数可以轻易实现，但有时候我们想在它delay的期间再次delay，直到最终不再delay的时候，才真正的被调用一次。这就需要每次先将旧的事件取消，然后重新设置delay。场景自动消失的视图例如当用户的某种操作点击一下屏幕就发出一条状态栏消息，消息在2秒后消失，在消失前如果用户又触发了这个条件，理应是在这次触发的2秒后消失，如果简单的使用dispatch_after函数进行延迟，结果会是在第一次点击的2秒后消失，可能你在1.5秒的时候又点击了一下，但是只过了0.5秒就消失了。降低服务器访问次数例如：用户修改了信息的30秒后上传至服务器。那么如果用户修改了姓名，然后30秒内又修改了头像，在修改了头像后的30秒内又修改了性别等等。我们希望的并不是每次修改就上传一次，而是在用户最后修改完所有信息之后，看起来似乎不准备继续修改了的时候，再上传至服务器。使用推迟而不重复执行的方法可以在避免多次访问服务器的同时及时地上传用户修改后的信息。AXKitDemo为了方便大家理解，我在Demo中做了这样一个页面，点击屏幕的时候计数器会增加，意味着收到某种需要处理的用户交互信息，2秒后作出回应（发出状态栏消息）。如果2秒内用户重复点击屏幕，那么这个回应会继续被推迟，直到某个连续的2秒没有收到任何输入，这时候才作出一次响应。实现的方法很简单，步骤如下：获取到函数取消函数重新赋值或启动使用Objective-C在Objective-C中，将要执行的代码保存成dispatch_block_t的静态类型变量，取出这个静态变量，然后使用dispatch_block_cancel()取消，然后重新设置它的值，然后调用dispatch_after。12345678910- (void)delayTest&#123; static dispatch_block_t task; if (task) &#123; dispatch_block_cancel(task); &#125; task = dispatch_block_create(DISPATCH_BLOCK_BARRIER, ^&#123; // 被推迟执行的代码 &#125;); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(duration * NSEC_PER_SEC)), dispatch_get_main_queue(), task);&#125;也可以使用AXKit实现也可以使用 AXKit 封装好的方法，将要执行的代码保存成ax_dispatch_operation_t的静态类型变量，使用ax_dispatch_cancel_operation()取消之前的任务，然后使用ax_dispatch_cancellable()再次赋值。1234567- (void)delayTest2&#123; static ax_dispatch_operation_t animationToken; ax_dispatch_cancel_operation(animationToken); animationToken = ax_dispatch_cancellable(duration, dispatch_get_main_queue(), ^&#123; // 被推迟执行的代码 &#125;);&#125;使用Swift创建静态变量static var task = DispatchWorkItem.init{}，先取消task.cancel()，再赋值DispatchWorkItem，然后使用DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: task)延迟调用。123456789internal static var task = DispatchWorkItem.init &#123;&#125;internal static func hide(duration: TimeInterval) &#123; task.cancel() task = DispatchWorkItem.init(block: &#123; // 被推迟执行的代码 &#125;) DispatchQueue.main.asyncAfter(deadline: .now() + duration, execute: task)&#125;"},{"title":"AXChartView 一个简单而漂亮的图表工具类","permalink":"https://xaoxuu.com/blog/2017-09-14-chartview/","text":"简单美观的统计图表，真的只有一个类！源码下载下载地址： https://github.com/xaoxuu/AXChartView/开始使用12345678910111213AXChartView *v1 = [[AXChartView alloc] initWithFrame:CGRectMake(16, 28, self.view.frame.size.width - 32, 200)];[self.view addSubview:v1];self.v1 = v1;v1.dataSource = self;v1.delegate = self;// 标题v1.title = @\"AXChartView\";// 线条粗细，默认为1v1.lineWidth = 2;// 平滑指数，默认为0，折线图v1.smoothFactor = 1;// 强调色，默认为灰色v1.accentColor = [UIColor orangeColor];设置数据源12345678910111213141516171819202122232425262728/** 总列数 @return 总列数 */- (NSUInteger)chartViewItemsCount&#123; return 7;&#125;/** 第index列的值 @param index 列索引 @return 第index列的值 */- (NSNumber *)chartViewValueForIndex:(NSUInteger)index&#123; return @(arc4random_uniform(20000));&#125;/** 第index列的标题 @param index 列索引 @return 第index列的标题 */- (NSString *)chartViewTitleForIndex:(NSUInteger)index&#123; return @(index+1).stringValue;&#125;自定义123456789101112131415161718// 每多少天显示一个列标题(当列数很多的时候用)- (NSInteger)chartViewShowTitleForIndexWithSteps&#123; return 2;&#125;// 右上角的摘要文字- (NSString *)chartViewSummaryText:(UILabel *)label&#123; return @\"haha\";&#125;// 渐变的背景色- (void)chartViewWillSetGradientLayer:(CAGradientLayer *)gradientLayer&#123; [gradientLayer setColors:@[(id)[UIColor colorWithRed:248/255.0 green:207/255.0 blue:54/255.0 alpha:1.00].CGColor, (id)[UIColor colorWithRed:253/255.0 green:166/255.0 blue:65/255.0 alpha:1.00].CGColor]]; [gradientLayer setStartPoint:CGPointMake(0, 0)]; [gradientLayer setEndPoint:CGPointMake(1, 1)];&#125;..."},{"title":"git 命令及客户端的详细使用","permalink":"https://xaoxuu.com/blog/2017-08-24-git/","text":"git教程：廖雪峰的git教程 、 git教程 。Git与SVN的区别git是分布式版本控制系统，SVN是集中式版本控制系统。详见： 集中式vs分布式 。git把内容按元数据方式存储，而SVN是按文件。git版本库可以离线查看所有log，可以离线提交，而SVN不可以。……更多区别详见： Svn与Git的区别 。操作流程SVNupdate（将远程版本库代码更新到本地）commit（将本地代码提交到远程版本库）gitcommit（将本地代码提交到远程版本库）fetch（将远程版本库的改动下载到本地（未合并））merge（合并两个分支（本地、远程））push（将最新的版本库同步到远程服务器）显而易见：SVN的操作简单明了，git学习成本比SVN高一点。但是由于git是分布式的，所以不需要联网就可以将代码改动立即提交。提交到本地版本库之后，本地和远程的版本就不一样了，因此需要fetch、merge、push来同步版本库。那么这点区别有什么意义呢？将代码提交到版本库里就有了记录，就可以查询可以恢复，相当于游戏的存档，而与远程服务器的交互因为需要网络，就有很大的不稳定因素，可能会失败，相当于游戏的打BOSS。SVN是将存档和打BOSS绑定到了一起，要打了BOSS后才可以存档进度；而git由于版本库在本地，所以随时随地可以存档，并且要求打BOSS前必须存档。使用git最大的感触就是安全（故障率低、易恢复）、速度快。开始使用git clone 克隆版本库123git clone https://github.com/xaoxuu/AXKit.git# 或者git clone https://github.com/xaoxuu/AXKit.git AXKitgit ignore 配置要忽略某些文件的改动需要配置.gitignore文件：123456789101112# 这是macOS文件夹属性的隐藏文件，不需要同步到git.DS_Store# 某个文件夹不想要同步到git/public/node_modules# 某个文件不想要同步到gittest.txt# 通配符._*日常操作add12# 把所有改动添加到版本库git add --allcommit12git commit -m 'message'# 注意，如果message没有空格的话，可以不加引号，言简意赅又节省时间。pull/push12345678# 更新所有分支git fetch# 将dev分支合并到当前分支git merge dev# 将更新后的本地分支同步到远程git push origin代码冲突我一般使用Tower客户端操作，pull之后有冲突的文件会列出来。建议使用一个比较好的编辑器如 Atom ，有冲突的部分会用两种颜色高亮。版本回退如果冲突文件没有妥善解决就提交到版本库导致严重后果，或者需要看到某个历史时刻的代码，都可以使用：12git log# 查看提交记录然后copy某个commit id，12345git reset [commit id]# 默认是soft，回到某个commit，而当前的代码依然在，处于未commit的状态。git reset --hard [commit id]# 彻底回到某个commit，完全回到那个时刻的状态。版本迭代分支branch查看当前所有分支1git branch新建并切换到新的分支dev1git checkout -b dev仅仅切换到dev分支1git checkout devdev分支push到远程1git push origin dev删除分支（dev）12345678# 删除本地分支git branch -d dev# 删除远程分支# 方法一：将空白分支覆盖到远程dev分支git push origin :dev# 方法二：执行删除命令git push origin --delete dev标签tag标签本质上和分支一样，适用于分支的操作也同样适用于标签，有区别的是：查看所有tag1git tag把当前HEAD打个tag（名为：1.0）123git tag 1.0# 也可以添加备注信息，如同commitgit tag 1.0 -m 'message'切换到某个tag（1.0）1git checkout 1.0push到远程1234# push所有未push的taggit push --tags# push指定的taggit push origin 1.0删除tag（1.0）12345678# 删除本地taggit tag -d 1.0# 删除远程tag# 方法一：将空白tag覆盖到远程taggit push origin :1.0# 方法二：执行删除命令git push origin --delete 1.0客户端Stash功能save：将当前未commit的代码保存到stash，并且回到上次commit的状态。apply：应用某个stash的代码。Git-Flow功能自动化管理功能，例如准备开发2.0版本的时候：点击Start Release，客户端会自动新建一个release分支。准备增加一个新特性的时候：点击Start Feature，客户端会新建一个feature分支。需要修复bug的时候：点击Start Hotfix，客户端会新建一个fix分支。当修复完bug，点击Finish Hotfix的时候，客户端会自动把fix分支合并到创建它的分支，并且创建一个tag。当一个新特性开发完成，点击Finish Feature的时候，客户端会自动把feature分支合并到创建它的分支，并且创建一个tag。当一个新版本开发完成，点击Finish Release的时候，客户端会自动把release分支合并到创建它的分支，并且创建一个tag。"},{"title":"如何搭建基于 Hexo 的独立博客","permalink":"https://xaoxuu.com/blog/2017-07-05-hexo-blog/","text":"如果你的电脑是 macOS 系统，又比较懒，你可以选择使用下面这行脚本命令全程自动化完成，下面文章就可以不用看了。打开终端，cd 到你想创建博客的地方，执行这一行命令：1curl -O 'https://raw.githubusercontent.com/xaoxuu/hexo.sh/master/hexo.sh' -# &amp;&amp; chmod 777 hexo.sh &amp;&amp; . hexo.sh -i init当然，如果你想知其所以然，最好还是看一下本文。配置环境安装Node.jsHexo依赖Node.js和git。如果电脑上没有node环境可以去 Nodejs官网 下载，或者在这里直接下载 node-v6.11.0.pkg 。安装完成可以查看版本，在终端输入：1npm -v当看到如下信息时，说明已经安装成功。安装gitmacOS自带git，可以跳过此步骤。Windows: Download &amp; install git.Mac: Install it with Homebrew, MacPorts or installer.Linux (Ubuntu, Debian): sudo apt-get install git-coreLinux (Fedora, Red Hat, CentOS): sudo yum install git-core安装Command Line ToolsmacOS需要安装Command Line Tools，Windows可以跳过这一步骤。在终端输入：1xcode-select --install然后会弹出一个提示框：点击Install安装。安装hexo在终端输入：1npm install hexo-cli -g如图：如果安装失败，显示这样的信息如图：则需要以管理员身份运行，在终端输入：1sudo npm install hexo-cli -g看到这个结果就表明安装成功了：开始创作1234hexo init blogcd blognpm installhexo server选择一个主题执行完上面几条命令之后，在浏览器打开地址：http://localhost:4000/就会看到hexo为你提供的默认主题。如果你不喜欢hexo自带的主题，可以去 hexo官网 找个喜欢的主题。下载主题源码到.../你的博客/themes/里面，根据主题的README文档提示，可能需要安装一些依赖包，或者对主题的_config.myl文件进行修改。如果你想使用本站的博客主题的话，只需要打开终端，cd到你博客所在的目录，执行以下这条命令：1hexo.sh i x如果提示 command not found ，说明你的电脑上还没有使用过 hexo.sh 脚本，那么可以执行下面这一段命令下载脚本然后应用主题：1curl -O 'https://raw.githubusercontent.com/xaoxuu/hexo.sh/master/hexo.sh' -# &amp;&amp; chmod 777 hexo.sh &amp;&amp; . hexo.sh -i i x写下第一篇博文你可以按照 官方文档 的方法去创建一个具有初始化内容的md文件到.../你的博客/source/_posts/位置，当然也可以通过其他任意方式创建md文件，只要文件开头有如下格式的内容即可：123456789101112131415---layout: postdate: 2017-07-05title: 如何搭建基于Hexo的独立博客categories: Cocoa Devtags: - blog - Hexo---这是预览&lt;!--more--&gt;这是正文发布博客博客发布到服务器才能被外网访问，如果你有服务器更好，可以支持一些有趣的功能，例如 hexo-admin 可以为你的博客增加后台管理功能，在其他地方只要登录管理员账号就可以在线写博文了。但是如果没有自己的服务器的，也可以将博客托管到 GitHub 、 Coding 等网站。他们的优缺点如下：GitHub优点：功能最强大，最知名，偏技术性的博客力荐。缺点：国内访问稍慢（以前是很慢，现在已经好多了，但是仍不及国内的服务快）；GitHub服务器屏蔽了百度爬虫，要想被百度收录，需要去百度站长平台手动提交。Coding优点：国内访问速度很快，一键申请并配置好SSL证书，很容易被百度收录。缺点：只能通过CNAME方式设置域名，也就意味着你不能同时使用域名邮箱等其他域名服务。常用的命令有：123hexo cleanhexo ghexo d暂时先更到这里，有什么疑问随时可以问我，或者在下方DISQUS留言。"},{"title":"iOS 接入 Strava 分享模块（下篇：StravaSDK）","permalink":"https://xaoxuu.com/blog/2017-06-28-ios-strava/","text":"StravaKit 是一个比较新而且代码比较规范的第三方SDK，但是目前还没有上传功能（详见 todo） 。所以我不得已对StravaKit 0.9.5增加上传功能，并进行一些简单封装和改编，使之能够植入到公司项目中。由于时间有限，我只增加了上传fit文件的功能，并且使用了第三方框架Alamofire，所以需要在项目中导入Alamofire。开始使用StravaSDK下载：StravaSDK.zip配置环境需要三个参数：ClientId、ClientSecret和app的URLSchemes。其中前两个是在 Strava平台 注册一个app的时候会给出。示例代码：1StravaSDK.config(clientId: \"18583\", clientSecret: \"a05fde98a830effde2e0f84cc39d76b040d4d67e\", appSchemes: \"hitfit\")授权获取授权1StravaSDK.authorize()取消授权1StravaSDK.deauthorize()查询是否已授权1StravaSDK.isAuthorized上传活动数据（.fit）123StravaSDK.uploadActivity(path: \".../test.fit\", type: \"run\", name: \"Afternoon Run\") &#123; (response, error) in&#125;相关资料： Strava官方文档 ， StravaKit源码 ， StravaSDK源码"},{"title":"Swift 使用 Alamofire 框架上传文件","permalink":"https://xaoxuu.com/blog/2017-06-26-swift-alamofire/","text":"Alamofire 是一个在GitHub上star数已超过24k的网络库。先贴出一段代码，这是我在StravaKit中增加的上传fit文件功能：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768extension Requestor &#123; public func uploadFitFile(url: String, params: [String : String]?, file: URL, completionHandler: ((_ response: Any?, _ error: NSError?) -&gt; ())?) &#123; guard let accessToken = Strava.sharedInstance.accessToken else &#123; let error = Strava.error(.noAccessToken, reason: \"No Access Token\") completionHandler?(nil, error) return &#125; debugPrint(accessToken) let au = \"Bearer \\(accessToken)\" let headers = [\"Authorization\": au] Alamofire.upload(multipartFormData: &#123; (multipartFormData) in if let params = params &#123; for (key, value) in params &#123; multipartFormData.append(value.data(using: .utf8)!, withName: key) &#125; &#125; multipartFormData.append(file, withName: \"file\", fileName: file.lastPathComponent, mimeType: \"multipart/form-data\") &#125;, usingThreshold: SessionManager.multipartFormDataEncodingMemoryThreshold, to: baseUrl + url, method: .post, headers: headers) &#123; (encodingResult) in switch encodingResult &#123; case .success(let upload, _, _): upload.responseJSON(completionHandler: &#123; (response) in if let value = response.result.value &#123; let dict = value as! Dictionary&lt;String, Any&gt;; var error = response.result.error as NSError? if let err = dict[\"error\"] &#123; if (err as AnyObject).isKind(of: NSNull.self) &#123; // 成功 debugPrint(\"成功\") &#125; else &#123; // 失败 debugPrint(\"失败\",err) error = NSError.init(domain: \"strava\", code: 0, userInfo: [NSLocalizedDescriptionKey:err]) &#125; &#125; if let completionHandler = completionHandler &#123; completionHandler(response.result,error) &#125; &#125; else &#123; if let completionHandler = completionHandler &#123; if let error = response.result.error &#123; completionHandler(response.result,error as NSError) &#125; &#125; &#125; &#125;) case .failure(let error): print(error) &#125; &#125; &#125;&#125;"},{"title":"iOS 接入 Strava 分享模块（上篇：FitSDK）","permalink":"https://xaoxuu.com/blog/2017-06-22-ios-fitsdk/","text":"fit 是一种文件协议，体积小巧，多用于可穿戴设备记录、传输运动与健康数据。官方提供了C、C++、Java语言的SDK和非常详细的使用文档。因此在iOS端接入fit就需要在C或C++的SDK基础上进行一点面向对象的封装。SDK下载官方SDK.zipFitSDK for iOS （我基于官方C语言版SDK的OC封装）认识Fit我使用的C语言的SDK，官方有示例demo，在fit_mgr文件中提供了一些示例，这些代码未必全部都要用到。创建一个最简单的.fit文件的流程是：写fileid123456789101112131415161718192021222324252627282930313233343536void fit_transaction_file(FIT_FILE type, FIT_MANUFACTURER manufacturer, FIT_UINT16 product, FIT_UINT32Z serial_number)&#123; // Write file id message. FIT_UINT8 local_mesg_number = 0; FIT_FILE_ID_MESG file_id; Fit_InitMesg(fit_mesg_defs[FIT_MESG_FILE_ID], &amp;file_id); // @xaoxuu: type FIT_FILE_ACTIVITY = 4 活动数据 file_id.type = type; // @xaoxuu: 厂商 file_id.manufacturer = manufacturer; // @xaoxuu: 产品 // file_id.product_name file_id.product = product; // @xaoxuu: 序列号 file_id.serial_number = serial_number; // @xaoxuu: 生产日期 // time_t now; // time(&amp;now); // file_id.time_created = now; WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FILE_ID], FIT_FILE_ID_MESG_DEF_SIZE, static_fp); WriteMessage(local_mesg_number, &amp;file_id, FIT_FILE_ID_MESG_SIZE, static_fp);&#125;void fit_transaction_field_desc() &#123; // Write a Field Description FIT_UINT8 local_mesg_number = 1; FIT_FIELD_DESCRIPTION_MESG field_description_mesg; Fit_InitMesg(fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], &amp;field_description_mesg); field_description_mesg.developer_data_index = 0; field_description_mesg.field_definition_number = 0; field_description_mesg.fit_base_type_id = FIT_BASE_TYPE_UINT16; WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_FIELD_DESCRIPTION], FIT_FIELD_DESCRIPTION_MESG_DEF_SIZE, static_fp); WriteMessage(local_mesg_number, &amp;field_description_mesg, FIT_FIELD_DESCRIPTION_MESG_SIZE, static_fp);&#125;写record123456789101112131415161718192021// 写入Record Defenitionvoid fit_transaction_record_def()&#123; FIT_UINT8 local_mesg_number = 2; WriteMessageDefinition(local_mesg_number, fit_mesg_defs[FIT_MESG_RECORD], FIT_RECORD_MESG_DEF_SIZE, static_fp);&#125;// 循环写入record数据void fit_transaction_record_msg(unsigned int timestamp, int position_lat, int position_long, unsigned int distance, unsigned short altitude, unsigned short speed, unsigned char heart_rate)&#123; //Record message FIT_UINT8 local_mesg_number = 2; FIT_RECORD_MESG record; Fit_InitMesg(fit_mesg_defs[FIT_MESG_RECORD], &amp;record); record.timestamp = timestamp; record.position_lat = position_lat; record.position_long = position_long; record.distance = distance; record.altitude = altitude; record.speed = speed; record.heart_rate = heart_rate; WriteMessage(local_mesg_number,&amp;record,FIT_RECORD_MESG_SIZE,static_fp);&#125;开始封装设计模型FitActivity.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//// FitAcitvity.h// FitSDK//// Created by xaoxuu on 04/07/2017.// Copyright © 2017 xaoxuu. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;@class FitActivityRecord;typedef NS_ENUM(NSUInteger, FitActivityType) &#123; FitActivityTypeWalk = 11, // 枚举值等于FIT_SPORT值 FitActivityTypeRun = 1, FitActivityTypeRide = 2, FitActivityTypeSwim = 5, FitActivityTypeHike = 17,&#125;;@interface FitActivity : NSObject// @xaoxuu: fit 文件路径@property (copy, readonly, nonatomic) NSString *path;// @xaoxuu: 活动名@property (copy, nonatomic) NSString *name;// @xaoxuu: 活动类型@property (assign, nonatomic) FitActivityType type;// @xaoxuu: 活动类型@property (copy, readonly, nonatomic) NSString *typeString;// @xaoxuu: records@property (strong, nonatomic) NSMutableArray&lt;FitActivityRecord *&gt; *records;/** 添加一条record @param record record */- (void)addRecord:(void (^)(FitActivityRecord *aRecord))record;@end@interface FitActivityRecord : NSObject// @xaoxuu: timestamp@property (assign, nonatomic) unsigned int timestamp;// @xaoxuu: position_lat@property (assign, nonatomic) int position_lat;// @xaoxuu: position_long@property (assign, nonatomic) int position_long;// @xaoxuu: distance@property (assign, nonatomic) unsigned int distance;// @xaoxuu: altitude@property (assign, nonatomic) unsigned short altitude;// @xaoxuu: speed@property (assign, nonatomic) unsigned short speed;// @xaoxuu: heart_rate@property (assign, nonatomic) unsigned char heart_rate;@endFitActivity.m1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889//// FitAcitvity.m// FitSDK//// Created by xaoxuu on 04/07/2017.// Copyright © 2017 xaoxuu. All rights reserved.//#import \"FitAcitvity.h\"@implementation FitActivity- (instancetype)init &#123; if (self = [super init]) &#123; _records = [NSMutableArray array]; self.type = FitActivityTypeWalk; &#125; return self;&#125;- (void)setType:(FitActivityType)type&#123; _type = type; switch (type) &#123; case FitActivityTypeWalk: _typeString = @\"walk\"; break; case FitActivityTypeRun: _typeString = @\"run\"; break; case FitActivityTypeRide: _typeString = @\"ride\"; break; case FitActivityTypeSwim: _typeString = @\"swim\"; break; case FitActivityTypeHike: _typeString = @\"hike\"; break; &#125;&#125;- (void)setName:(NSString *)name&#123; _name = name; _path = [self pathWithName:name];&#125;- (void)addRecord:(void (^)(FitActivityRecord *aRecord))record&#123; if (record) &#123; FitActivityRecord *rec = [FitActivityRecord new]; record(rec); [self.records addObject:rec]; &#125;&#125;- (NSString *)pathWithName:(NSString *)name&#123; NSString *path = [[NSTemporaryDirectory() stringByAppendingPathComponent:@\"com.xaoxuu.fitsdk\"] stringByAppendingPathComponent:name]; path = [path stringByAppendingPathExtension:@\"fit\"]; // create dir if not exist NSFileManager *fm = [NSFileManager defaultManager]; NSString *dir = path.stringByDeletingLastPathComponent; BOOL result = [fm createDirectoryAtPath:dir withIntermediateDirectories:YES attributes:nil error:nil]; if (!result) &#123; NSLog(@\"can not create the directory at path %@\",dir); &#125; return path;&#125;@end@implementation FitActivityRecord- (instancetype)init&#123; if (self = [super init]) &#123; _timestamp = 702940946; _position_lat = 0; _position_long = 0; _distance = 0; _altitude = 0; _speed = 0; _heart_rate = 0; &#125; return self;&#125;@end封装接口FitSDK.h12345678910111213141516171819202122//// FitSDK.h// FitSDK//// Created by xaoxuu on 04/07/2017.// Copyright © 2017 xaoxuu. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#import \"FitAcitvity.h\"@interface FitSDK : NSObject/** 创建一个活动数据fit文件 @param activity 活动数据 @return 活动数据模型 */+ (FitActivity *)createActivity:(void (^)(FitActivity *activity))activity;@endFitSDK.m12345678910111213141516171819202122232425262728293031323334//// FitSDK.m// FitSDK//// Created by xaoxuu on 04/07/2017.// Copyright © 2017 xaoxuu. All rights reserved.//#import \"FitSDK.h\"#import \"fit_mgr.h\"@implementation FitSDK+ (FitActivity *)createActivity:(void (^)(FitActivity *activity))activity&#123; FitActivity *act = [FitActivity new]; if (activity) &#123; activity(act); &#125; [self createActivityWithModel:act]; return act;&#125;+ (void)createActivityWithModel:(FitActivity *)activity&#123; // @xaoxuu: fit file const char *fp = [activity.path cStringUsingEncoding:NSUTF8StringEncoding]; fit_transaction(fp, activity.type, ^&#123; [activity.records enumerateObjectsUsingBlock:^(FitActivityRecord * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123; fit_transaction_record_msg(obj.timestamp, obj.position_lat, obj.position_long, obj.distance, obj.altitude, obj.speed, obj.heart_rate); &#125;]; &#125;);&#125;@end使用1234567891011121314151617FitActivity *activity = [FitSDK createActivity:^(FitActivity *activity) &#123; activity.name = @\"test\"; activity.type = FitActivityTypeRun; for (int i = 0; i&lt;100; i++) &#123; [activity addRecord:^(FitActivityRecord *aRecord) &#123; aRecord.timestamp = [[NSDate date] timeIntervalSince1970] - 631065600; aRecord.position_lat = 495280430+i*1000; aRecord.position_long = -872696681-i*1500; aRecord.distance = 2+i/100; aRecord.altitude = 287.2+i; aRecord.speed = 0.29+i/50; aRecord.heart_rate = 68+i/4; &#125;]; &#125;&#125;];// activity.path就是生成的fit文件路径NSLog(@\"%@\", activity.path);"},{"title":"iOS 让代码实现“冷却”机制","permalink":"https://xaoxuu.com/blog/2017-05-07-code-cooldown/","text":"首先我个人认为设计合理、逻辑严谨的代码是不需要强行冷却的，但是我们不能保证我们面对的代码永远都是完美的，所以我在 AXKit 中就提供了这个冷却机制以延长那些癌症晚期的代码的寿命。优点：执行代码像放技能一样，可以强行打破死循环、避免死循环、避免过高频率访问某一资源。缺点：治标不治本，最好的解决办法是找出会产生问题的代码进行重构，从根源上解决问题。应用场景场景1某种耗时耗能的操作，希望在某种条件下触发，但又担心用户频繁触发，例如进入某个页面的时候同步一下设备电量、或者同步一下运动数据；进入某个页面预加载一下子页面的网络数据……就可以这样：12345678910// @xaoxuu: 重新获取数据源并刷新tableView- (void)reloadDataAndRefreshTableView&#123; // 无论如何，2秒内最多只会执行一次此方法。 ax_dispatch_cooldown(0, 2, @\"reload data and refresh table view\", dispatch_get_main_queue(), ^&#123; [self.dataList removeAllObjects]; [self reloadTableView]; &#125;, ^&#123; AXLogFailure(@\"操作过于频繁\"); &#125;);&#125;123456789101112131415161718- (IBAction)btn1:(UIButton *)sender &#123; // @xaoxuu: 立即在主线程施放大招，冷却时间是60秒。 ax_dispatch_cooldown(0, 60, self, dispatch_get_main_queue(), ^&#123; AXLogSuccess(@\"技能施放成功！\"); &#125;, ^&#123; AXLogFailure(@\"抱歉，技能在冷却中\"); &#125;);&#125;- (IBAction)btn2:(UIButton *)sender &#123; // @xaoxuu: 延迟2秒后在后台默默施放大招，冷却时间是120秒。 ax_dispatch_cooldown(2, 120, self, dispatch_get_global_queue(0, 0), ^&#123; AXLogSuccess(@\"技能施放成功！\"); &#125;, ^&#123; AXLogFailure(@\"抱歉，技能在冷却中\"); &#125;);&#125;// @xaoxuu: 两者的token相同则共享冷却时间。场景2如何强行打破死循环？说实话我是没有遇到这种需求，仅仅是这个机制有这种能力，觉得挺有趣，就尝试一下：12345// @xaoxuu: 自己调用自己，无限循环- (void)loop&#123; AXLogFunc(); [self loop];&#125;1234567// @xaoxuu: 自己调用自己，但是发现代码在冷却，所以就失效了，一个环节被中断，死循环就被打破了- (void)loop&#123; AXLogFunc(); ax_dispatch_cooldown(0, 0.0001, @\"loop\", dispatch_get_main_queue(), ^&#123; [self loop]; &#125;, nil);&#125;实现原理简单地说，就是给每一个代码块分配一个dispatch_after的函数，执行的时候开始计时，并且函数标记为disable，计时结束后重新enable。1234567891011121314151617181920212223242526272829303132/** 拥有冷却机制的dispatch @param delay 延迟时间 @param cooldown 冷却时间 @param token 冷却计时的token，如果相同，则共享冷却时间 @param queue 指定线程 @param block 要执行的block @param block_cooling 如果在冷却中要执行的block @return 操作口令（用于取消此操作） */inline ax_dispatch_operation_t ax_dispatch_cooldown(NSTimeInterval delay, NSTimeInterval cooldown,id token, dispatch_queue_t queue, void (^block)(void), void (^ __nullable block_cooling)(void))&#123; if (!token) &#123; token = @\"default token\"; &#125; if (!queue) &#123; queue = dispatch_get_main_queue(); &#125; BOOL cooling = is_cooling(token); if (cooling) &#123; if (block_cooling) &#123; block_cooling(); &#125; &#125; else &#123; set_is_cooling(YES, token); dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(cooldown * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; set_is_cooling(NO, token); &#125;); return ax_dispatch_cancellable(delay, queue, block); &#125; return nil;&#125;其中，对于代码是否正在冷却的判断利于了runtime机制，相当于新增了一个属性，用来保存是否正在冷却的状态：12345678910111213static const void *AXBlockWrapperKey = &amp;AXBlockWrapperKey;static inline BOOL is_cooling(id token)&#123; NSNumber *cooling = objc_getAssociatedObject(token, AXBlockWrapperKey); return cooling.boolValue;&#125;static inline void set_is_cooling(BOOL cooling, id token)&#123; if (!token) &#123; token = @\"\"; &#125; objc_setAssociatedObject(token, AXBlockWrapperKey, @(cooling), OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;"},{"title":"Runtime 简单应用：AXKit手势分类实现原理","permalink":"https://xaoxuu.com/blog/2017-04-07-gesture/","text":"手势的应用场景很多，如果你觉得系统给我们提供的方法使用起来并不那么方便，那么本文可能对你有帮助，因为我用block对其进行了封装。应用场景场景1：为了调试某个功能，快速给一个视图添加手势，要求轻触的时候执行某段代码。场景2：tabbar按钮双击刷新列表，要求双击的速度在一秒内，执行某段代码。场景3：给某个图片添加捏合手势以及旋转手势。……使用AXKit，可以轻易实现上述几种场景中的需求：123456789101112131415161718192021222324[self.view ax_addTapGestureHandler:^(UITapGestureRecognizer * _Nonnull sender) &#123; // 轻触的时候要执行的代码&#125;];[self.view ax_addDoubleTapGesture:nil duration:1 handler:^(UITapGestureRecognizer * _Nonnull sender) &#123; // 双击的时候要执行的代码&#125;];// 捏合手势[self.view ax_addPinchGesture:^(UIPinchGestureRecognizer * _Nonnull sender) &#123; // 对手势对象（sender）的配置 sender.view.transform = CGAffineTransformScale(sender.view.transform, sender.scale, sender.scale); sender.scale = 1;&#125; handler:^(UIPinchGestureRecognizer * _Nonnull sender) &#123; // 捏合的时候要执行的代码&#125;];// 旋转手势[self.view ax_addRotationGesture:^(UIRotationGestureRecognizer * _Nonnull sender) &#123; // 对手势对象（sender）的配置 sender.view.transform = CGAffineTransformRotate(sender.view.transform, sender.rotation); sender.rotation = 0;&#125; handler:^(UIRotationGestureRecognizer * _Nonnull sender) &#123; // 旋转的时候要执行的代码&#125;];开始使用推荐CocoaPods方式，在podfile中添加一行：1pod 'AXKit'然后在终端中执行pod install即可完成安装。AXKit的全局头文件是：1234// 通过CocoaPods或静态库方式安装#import &lt;AXKit/AXKit.h&gt;// 通过手动方式#import \"AXKit.h\"接口声明直接上头文件源码，注释很详细：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#import &lt;UIKit/UIKit.h&gt;NS_ASSUME_NONNULL_BEGIN@interface UIView (AXGestureExtension)/** 处理tap手势 @param handler 处理手势的block */- (void)ax_addTapGestureHandler:(void (^)(UITapGestureRecognizer *sender))handler;/** 添加一个tap手势，并处理 @param tap tap @param handler 处理手势的block */- (void)ax_addTapGesture:(nullable void (^)(UITapGestureRecognizer *sender))tap handler:(void (^)(UITapGestureRecognizer *sender))handler;/** 添加一个tap手势，并处理，附加动画效果 @param tap tap @param handler 处理手势的block @param scale 动画比例 @param duration 持续时间 */- (void)ax_addTapGesture:(nullable void (^)(UITapGestureRecognizer *sender))tap handler:(void (^)(UITapGestureRecognizer *sender))handler animatedScale:(CGFloat)scale duration:(NSTimeInterval)duration;/** 添加一个双击手势，并处理 @param doubleTap double tap @param duration 双击间隔时间 @param handler 处理手势的block */- (void)ax_addDoubleTapGesture:(nullable void (^)(UITapGestureRecognizer *sender))doubleTap duration:(NSTimeInterval)duration handler:(void (^)(UITapGestureRecognizer *sender))handler;/** 添加一个长按手势，并处理 @param longPress 长按手势 @param handler 处理手势的block */- (void)ax_addLongPressGesture:(nullable void (^)(UILongPressGestureRecognizer *sender))longPress handler:(void (^)(UILongPressGestureRecognizer *sender))handler;/** 添加一个轻扫手势，并处理 @param swipe 轻扫 @param handler 处理手势的block */- (void)ax_addSwipeGesture:(nullable void (^)(UISwipeGestureRecognizer *sender))swipe handler:(void (^)(UISwipeGestureRecognizer *sender))handler;/** 添加一个滑动手势，并处理 @param pan 滑动 @param handler 处理手势的block */- (void)ax_addPanGesture:(nullable void (^)(UIPanGestureRecognizer *sender))pan handler:(void (^)(UIPanGestureRecognizer *sender))handler;/** 添加一个屏幕边缘滑动手势，并处理 @param screenEdgePan 屏幕边缘滑动 @param handler 处理手势的block */- (void)ax_addScreenEdgePanGesture:(nullable void (^)(UIScreenEdgePanGestureRecognizer *sender))screenEdgePan handler:(void (^)(UIScreenEdgePanGestureRecognizer *sender))handler;/** 添加一个双指缩放手势，并处理 @param pinch 双指缩放手势 @param handler 处理手势的block sender.view.transform = CGAffineTransformScale(sender.view.transform, sender.scale, sender.scale); sender.scale = 1; */- (void)ax_addPinchGesture:(nullable void (^)(UIPinchGestureRecognizer *sender))pinch handler:(void (^)(UIPinchGestureRecognizer *sender))handler;/** 添加一个双指旋转手势，并处理 @param rotation 双指旋转手势 @param handler 处理手势的block sender.view.transform = CGAffineTransformRotate(sender.view.transform, sender.rotation); sender.rotation = 0; */- (void)ax_addRotationGesture:(nullable void (^)(UIRotationGestureRecognizer *sender))rotation handler:(void (^)(UIRotationGestureRecognizer *sender))handler;@endNS_ASSUME_NONNULL_END实现方法以最简单的tap手势为例，其实现如下：123456- (void)ax_addTapGestureHandler:(void (^)(UITapGestureRecognizer *sender))handler&#123; // 创建手势实例 UITapGestureRecognizer *gesture = [UITapGestureRecognizer new]; // 将手势和target绑定 AXBindGestureAndTarget(gesture, AXDefaultTarget);&#125;其中AXBindGestureAndTarget(gesture, AXDefaultTarget)用了inline函数：123static inline void AXBindGestureAndTarget(UIGestureRecognizer *gesture, AXEventTarget *target)&#123; [gesture addTarget:target action:@selector(handleEvent:)];&#125;AXDefaultTarget则是宏定义，因为大部分地方用到的都是固定的三个参数：123456789101112131415161718192021#define AXDefaultTarget AXTargetWith(self, gesture, handler)// 依据self类、手势实例、handler代码块创建一个唯一的targetstatic inline AXEventTarget *AXTargetWith(UIView *obj, __kindof UIGestureRecognizer *gesture, id handler)&#123; // create a target with &lt;handler&gt; AXEventTarget *target = [AXEventTarget targetWithHandler:handler]; // add a &lt;gesture&gt; to target [obj addGestureRecognizer:gesture]; // save target (gesture + handler) to dictionary NSMutableDictionary *gestures = objc_getAssociatedObject(obj, UIViewGestureAXBlockWrapperKey); if (!gestures) &#123; gestures = [NSMutableDictionary dictionary]; objc_setAssociatedObject(obj, UIViewGestureAXBlockWrapperKey, gestures, OBJC_ASSOCIATION_RETAIN_NONATOMIC); &#125; NSMutableSet *handlers = gestures[NSStringFromPointer(gesture)]; if (!handlers) &#123; handlers = [NSMutableSet set]; gestures[NSStringFromPointer(gesture)] = handlers; &#125; [handlers addObject:target]; return target;&#125;这里用到了一个AXEventTarget类，这个类的功能就是保存handler，并在需要的时候执行handler。这个分类的实现参考了BlocksKit的实现原理，对其进行扩展，用到了runtime机制，至于什么是runtime，我们稍后再作讨论。本文稍后会进行更新，补充实现的思路、更详细的细节。附：关于runtimeruntime是运行时一些机制，其中最主要的是消息机制。它与编译时语言的最大区别在于它在运行的时候才去确定要调用的函数类型，如果一个方法没有实现体，那么在编译阶段调用并不会报错，而编译时语言调用一个未实现的函数就会报错。运行时语言调用方法的本质是让对象发送消息，属于动态调用，编译时并不能真正决定调用哪个方法。下面是runtime的一些应用场景：动态添加方法拦截系统自带的方法调用(Swizzle)、交换方法json转模型（KVC）给分类增加属性实现NSCoding的归档解档万能控制器跳转JSpatch热更新（苹果不再允许使用热更新）插件的开发（Xcode8已禁止插件）"},{"title":"iOS 分层架构初探","permalink":"https://xaoxuu.com/blog/2017-03-29-ios-layered-architecture/","text":"这篇博客把分层架构讲的很形象： 三层架构(我的理解及详细分析) 。为什么要分层代码系统分层就好比管理分层一样，各司其职，优点非常多，对于软件后期的维护来说是十分有必要的。它的优点有：解耦上一层依赖于下一层，如果测试下一层没有问题，那么问题就只有可能发现在本层了，便于发现和改正BUG。体现了“高内聚，低耦合”的思想。分工明确各个层次分工明确，将一个复杂问题简单拆分了。便于维护各层间通过接口解耦，接口与实现分离，从而可以非常简单的替换掉实现，或者实际实现等。逻辑复用（代码复用）和劳动成本的减少分层的根本在于代码的复用和劳动成本的减少。分层的最理想化的结果是实现层与层之间的互不依赖的内部实现，所谓的即插即用。"},{"title":"Excel 导出 iOS、Android 多国语言工具","permalink":"https://xaoxuu.com/blog/2017-03-08-ios-localizable-string/","text":"1. 下载，解压下载工具：https://github.com/CatchZeng/Localizable.strings2Excel 。解压开之后把里面的两个zip也解压开2. 安装工具pyexcelerator打开命令行工具，cd到.../Localizable.strings2Excel-master/pyexcelerator-0.6.4.1文件夹，执行：1sudo python setup.py installxldcd到.../Localizable.strings2Excel-master/xlrd-1.0.0文件夹，执行：1sudo python setup.py install3. 使用脚本cd到.../Localizable.strings2Excel-master/python文件夹如需将Excel表格转换成Localizable.strings或者strings.xml文件，执行：1python LocalizableBack.py -f xxx/xxx.xls -t xxx/xxx如需将Localizable.strings或者strings.xml文件转换成Excel表格，执行：1python Localizable.py -f xxx/ -t xxx/工具的链接在：GitHub/CatchZeng 感谢作者编写了如此方便的工具！更多详细使用脚本请阅读官方README文件 。"},{"title":"NEXUS 这个工具，以后不再更新了","permalink":"https://xaoxuu.com/blog/2017-01-02-nexus/","text":"前几天一哥们发现了一个小BUG，立即打开尘封已久的 NEXUS 项目，发现距离上次更新已经时隔一年。以后我几乎不再使用 Windows 系统了，所以不出意外的话这就是最后一次更新了。那么，什么是 NEXUS ？简单地说，就如同电脑管家+快捷搜索+激活工具集锦+……NEXUS（魔枢）意为联接、沟通，在《魔兽》里翻译为魔枢，《星际迷航》里翻译为时汇。软件以此为名旨在连通问题与答案，终极目标即输入任何问题或需求，即可一步达到目的，成为一个信息的枢纽。魔枢的方便之处在于：点击屏幕左上角，即可呼出搜索栏，此搜索栏对于一些常用的网站如[优酷]、[淘宝]等等可以直达官网，省去了搜索引擎检索的步骤。左上角热键是透明的，不影响视觉，只有在允许魔枢后台运行时才会生效。适用平台Windows 7~10开始使用下载安装包： NEXUS-setup.exe下载扩展包： Extension20160207.exe源码大学的时候不知道GitHub，所以这是最近才上传的： https://github.com/xaoxuu/NEXUS 。"},{"title":"封装 .framework 静态库","permalink":"https://xaoxuu.com/blog/2016-11-06-ios-framework/","text":"像工作中使用的第三方SDK基本上都是闭源的，因为公司不能把自己的机密泄露出去。所以当需要给别人提供SDK但不让他们知道代码的实现时就需要封装成静态库。静态库有.a库和.framework库，苹果官方更建议我们使用.framework库，因为其更加强大。.a是一个纯二进制文件，.framework中除了有二进制文件之外还有资源文件。.a文件不能直接使用，至少要有.h文件配合，.framework文件可以直接使用。.a + .h + sourceFile = .framework。步骤参考这篇博客： iOS开发——创建你自己的Framework 讲解的非常详细。总结一下步骤：创建工程，最好是起名为xxxDemo例如AXKitDemo，然后新建一个target名为AXKit，并把原来的工程改名为AXKit。（为了方便在demo中调试静态库）新建一个target，选择类型为framework。在framework中创建需要封装的类，写好代码。在Build Setting里更改参数，Math-O Type为Static Library。在Build Phases -&gt; Headers里将需要暴露出来的头文件从Project移动到Public。添加一个Aggregate的target，并添加运行脚本。目的是把编译出来的真机版和模拟器版的framework合并。模拟器编译一下，真机编译一下，然后Aggregate编译一下，然后在项目的Products文件夹里就有了最终生成的静态库。Aggregate的Run Script脚本：123456789101112131415161718192021222324if [ \"$&#123;ACTION&#125;\" = \"build\" ]thenINSTALL_DIR=$&#123;SRCROOT&#125;/Products/$&#123;PROJECT_NAME&#125;.frameworkDEVICE_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;PROJECT_NAME&#125;.frameworkSIMULATOR_DIR=$&#123;BUILD_ROOT&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;PROJECT_NAME&#125;.frameworkif [ -d \"$&#123;INSTALL_DIR&#125;\" ]thenrm -rf \"$&#123;INSTALL_DIR&#125;\"fimkdir -p \"$&#123;INSTALL_DIR&#125;\"cp -R \"$&#123;DEVICE_DIR&#125;/\" \"$&#123;INSTALL_DIR&#125;/\"#ditto \"$&#123;DEVICE_DIR&#125;/Headers\" \"$&#123;INSTALL_DIR&#125;/Headers\"lipo -create \"$&#123;DEVICE_DIR&#125;/$&#123;PROJECT_NAME&#125;\" \"$&#123;SIMULATOR_DIR&#125;/$&#123;PROJECT_NAME&#125;\" -output \"$&#123;INSTALL_DIR&#125;/$&#123;PROJECT_NAME&#125;\"#open \"$&#123;DEVICE_DIR&#125;\"#open \"$&#123;SRCROOT&#125;/Products\"fi"},{"title":"从 UIImageView 指定点取色","permalink":"https://xaoxuu.com/blog/2016-09-14-get-color/","text":"开发中有时候会遇到这样的需求，要给用户一个取色板，让用户从中自由地选取颜色，用来改变主题或者控制灯具的颜色等。这时候我们就需要获取一个视图的指定坐标的颜色值。使用场景有时候我们可能会需要一个取色器，例如我的蓝牙灯项目，让用户从一个取色器中随意取色：那么如何从一个图片中取色呢？ Stack Overflow 已经有大神给出了核心代码，这段代码是对UIImage的扩展，使用起来还不是很方便。于是我根据需求确定了接口：1234567/** 从圆形范围内的指定点获取UIColor对象，并在block中执行操作 @param point 指定坐标点 @param completion 取色完成后执行的block */- (void)ax_getColorFromCircleWithPoint:(CGPoint)point completion:(void (^)(UIColor *color))completion;调用起来应该是这样的：1234// 已知imageView、point[imageView ax_getColorFromCircleWithPoint:point completion:^(UIColor *color)&#123; // 在这里直接用color&#125;];因为取色板一般是圆形的，如果坐标点超出了圆形但依然在imageView的frame内，可能会返回一些用户不期望的结果，用block巧妙地解决了这一问题，超出范围就不再有回调。如果你认为我的封装使用起来更加方便，可以继续阅读下面详细内容。开始使用推荐CocoaPods方式，在podfile中添加一行：1pod 'AXKit'然后在终端中执行pod install即可完成安装。AXKit的全局头文件是：1234// 通过CocoaPods或静态库方式安装#import &lt;AXKit/AXKit.h&gt;// 通过手动方式#import \"AXKit.h\"接口声明从指定点获取RGBA值1234567- (void)ax_getRed:(nullable CGFloat *)red green:(nullable CGFloat *)green blue:(nullable CGFloat *)blue alpha:(nullable CGFloat *)alpha withPoint:(CGPoint)point;// 调用起来是这样的：// 已知imageView、pointCGFloat r,g,b,a;[imageView ax_getRed:&amp;r green:&amp;g blue:&amp;b alpha:&amp;a withPoint:point];// 然后r/g/b/a就有了值需要自己创建变量，然后把地址传进去，然后才能用，不推荐直接使用。从指定点获取RGBA值，并在block中执行操作加了一个block，调用起来就方便许多：1234567- (void)ax_getRGBAWithPoint:(CGPoint)point completion:(void(^)(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha))completion;// 调用起来是这样的：// 已知imageView、point[imageView ax_getRGBAWithPoint:point completion:^(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha)&#123; // 在这里直接用red/green/blue/alpha&#125;];优点是不需要自己创建变量，直接调用方法，在block回调里直接获得red/green/blue/alpha值。但是，很多时候，我们用的取色器是圆形的，就需要再进行一点封装。从圆形范围内的指定点获取RGBA值，并在block中执行操作1234567- (void)ax_getRGBAFromCircleWithPoint:(CGPoint)point completion:(void (^)(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha))completion;// 调用起来是这样的：// 已知imageView、point[imageView ax_getRGBAFromCircleWithPoint:point completion:^(CGFloat red,CGFloat green,CGFloat blue,CGFloat alpha)&#123; // 在这里直接用red/green/blue/alpha&#125;];跟第2种调用方法一模一样，但是区别是超出圆形范围之后就不再执行block回调了，这是一种安全的做法。如果不用block方式，那么即使超出了圆形范围，也一定会返回对应的rgba值，会造成不想要的后果。block的回调机制巧妙地解决了这个问题。如果我想直接获得一个UIColor对象呢，跟获取RGBA一样有三种方法。从指定点获取UIColor对象123456- (nullable UIColor *)ax_getColorWithPoint:(CGPoint)point;// 调用起来是这样的：// 已知imageView、pointUIColor *color = [imageView ax_getColorWithPoint:point];// 获得UIColor对象由声明可以看出来，返回的值是一个可空类型，因此这跟第一种方法一样是不安全的。从指定点获取UIColor对象，并在block中执行操作1234567- (void)ax_getColorWithPoint:(CGPoint)point completion:(void(^)(UIColor *color))completion;// 调用起来是这样的：// 已知imageView、point[imageView ax_getColorWithPoint:point completion:^(UIColor *color)&#123; // 在这里直接用color&#125;];这种方法比第4种要方便一些，如果超出UIImageView的时候就不执行block里的代码。从圆形范围内的指定点获取UIColor对象，并在block中执行操作1234567- (void)ax_getColorFromCircleWithPoint:(CGPoint)point completion:(void (^)(UIColor *color))completion;// 调用起来是这样的：// 已知imageView、point[imageView ax_getColorFromCircleWithPoint:point completion:^(UIColor *color)&#123; // 在这里直接用color&#125;];引言中的Demo用的就是这一种方法，在圆形取色器中取色，既方便又安全。相关资料：Simple way to read pixel color values from an PNG image on the iPhone?"},{"title":"iOS 链式封装，更优雅地存取沙盒文件","permalink":"https://xaoxuu.com/blog/2016-09-12-sandbox/","text":"假如你需要把一个字典或者别的什么东西保存到沙盒里，你准备怎么做？也许你已经条件反射的想到了操作步骤……其实，你可以不必每次都那么老老实实的把每一步写出来，一行代码就可以了：1@\"文件名\".cachePath.save(要保存的内容);本质上就是把沙盒文件操作简化为：【路径+保存文件】两个关键点，组成一条链式语法。接入AXKit如果你的项目里还没有AXKit，可以在pod文件里添加一条pod &#39;AXKit&#39;进行接入，也可移步至 AXKit在线文档 查看详细的安装和使用方法。路径我封装了几个常用的沙盒路径，如下：1234- (nullable NSString *)mainBundlePath; // mainBundlePath就是主工程项目里的文件路径- (NSString *)docPath; // 文档，iTunes会备份，适合保存重要的数据- (NSString *)cachePath; // 缓存，iTunes不会备份，适合保存不太重要的较大的数据- (NSString *)tempPath; // 临时文件，iTunes不会备份，系统空闲时会自动删除，设备重启时也会删除除此之外，还提供了所有的路径，通过枚举的方式获取：1- (NSString *(^)(NSSearchPathDirectory))path; // 传入NSSearchPathDirectory枚举就可得到路径示例在沙盒的文档路径里有个叫abc.plist的文件，它的描述就是：1@\"abc.plist\".docPath;路径的拼接任何一个字符串都可以使用.append()进行拼接。保存保存的方法目前提供有四个：1234- (BOOL(^)(id))savePlist;- (BOOL(^)(NSObject&lt;NSCoding&gt; *))saveArchivedPlist;- (BOOL(^)(NSObject&lt;NSCoding&gt; *))saveArchivedObject;- (BOOL(^)(id &lt;NSCoding&gt;))save;示例在doc路径下保存一个名为”arr.plist”的文件：12NSArray *arr = [NSArray array];BOOL result = @\"arr\".docPath.savePlist(arr);在cache路径下归档一个名为”myfile.plist”的文件：123MyProfiles *myfile = [[MyProfiles alloc] init];// MyProfiles类需实现NSCoding协议BOOL result = @\"myfile\".cachePath.saveArchivedPlist(myfile);​读取读取的方法目前提供了七个：1234567- (nullable __kindof NSArray *)readArray;- (nullable __kindof NSDictionary *)readDictionary;- (nullable id)readArchivedPlist;- (nullable id)readJson;- (nullable NSString *)readTxt;- (nullable id)readArchivedFile;- (nullable id)readArchivedObject;示例在doc路径下读取一个名为”arr.plist”的文件：1NSArray *arr = @\"arr\".docPath.readArray;在cache路径下解档一个名为”myfile.plist”的文件：1MyProfiles *myfile = @\"myfile\".cachePath.readArchivedPlist;​查询遍历路径下所有文件12345// 获取doc/myDir 路径下所有的扩展名为\"plist\"文件路径NSArray *paths = @\"myDir\".docPath.subpaths(@\"plist\");// 如果传入值为空，则不区分扩展名获取所有文件路径NSArray *paths2 = @\"myDir\".docPath.subpaths(@\"\");// paths里面装的是doc/myDir路径下的所有文件完整路径删除结构：【路径+删除】1234- (BOOL)removePlist;- (BOOL)removeJson;- (BOOL)removeTxt;- (BOOL)remove;示例在doc路径下删除一个名为”arr.plist”的文件：1BOOL result = @\"arr.plist\".docPath.remove;在cache路径下删除一个名为”myfile.plist”的文件：1MyProfiles *myfile = @\"myfile.plist\".cachePath.remove;详细文档详细请看 文档 。"},{"title":"如何发布源码到 CocoaPods","permalink":"https://xaoxuu.com/blog/2016-08-11-cocoapods/","text":"说实在话，类似的教程网上很多，基本可以满足大多数人零基础发布CocoaPods，但是其中可能会遇到一些问题，只有亲自尝试过才知道。准备工作1. clone远程仓库到本地1git clone 你的仓库链接2. 注册trunk注册的命令1pod trunk register 你的邮箱 你的用户名记得去邮箱里验证，然后可以输入以下命令查看个人信息1pod trunk me步骤1. 创建.podspec1pod spec create AXKit2. 修改.podspec并验证有很多类似的教程，可以参考。一个小技巧：你可以去GItHub搜索一些热门的第三方库，然后点击查看这些大牛的 .podspec 是怎么写的。传送门：YYKit的podspec、ReactiveObjC的podspec、BlocksKit的podspec最容易出错的地方就是资源路径1s.source_files = \"AXKit/**/*.&#123;h,m&#125;\"常见写法123\"Directory1/*\" 表示匹配所有文件\"Directory1/Directory2/*.&#123;h,m&#125;\" 表示匹配所有以.h和.m结尾的文件\"Directory1/**/*.h\" 表示匹配所有子目录s.source 常见写法1234# 推荐写法：与版本号绑定s.source = &#123; :git =&gt; \"https://github.com/TeaseTian/HTQRCode.git\", :tag =&gt; \"#&#123;s.version&#125;\" &#125;# 与commit id 绑定s.source = &#123; :git =&gt; \"https://github.com/TeaseTian/HTQRCode.git\", :commit =&gt; \"68defea\" &#125;tag =&gt; s.version 表示将这个Pod版本与Git仓库中相同版本的comit绑定注意：如果仓库中对应的tag是 “v1.0.0”\b 这样以字母开头的，可以在 #{s.version} 前面加上对应的字母。commit =&gt; “68defea” 表示将这个Pod版本与Git仓库中某个commit绑定验证1pod spec lint AXKit.podspec3. 上传到远程仓库修改.podspec时指定的版本号，如 0.0.1。那么远程仓库中必须始终存在这个版本的 branch 或 tag 才能够下载。建议使用tag。s.source 中的tag需要与远程仓库中的tag对应起来。12s.version = \"0.0.1\"s.source = &#123; :git =&gt; \"https://github.com/xaoxuu/AXKit.git\", :tag =&gt; \"v#&#123;s.version&#125;\" &#125;这里指向的是 &quot;v0.0.1&quot; 这个分支，因为分支我们用完之后习惯把它删掉，所以这里也可以指向tag，也就是说打一个 &quot;v0.0.1&quot; 的tag并推送到远程就可以了。12git tag v0.0.1git push --tags这样做的好处就是删掉当前分支不影响CocoaPods中指向的仓库源码，对git命令不熟悉可以参考廖雪峰的git教程。4. 发布到CocoaPods1pod trunk push AXKit.podspecn. 删除一个podspec版本删除的命令是：1pod trunk delete 项目名 版本号官方建议使用 deprecate 来弃用1pod trunk deprecate 项目名这两种方法执行完有很大几率会出现一串很长很长的错误，不要着急，这实际上这是一个html。把它保存到一个html文件中，打开，是个404错误页。所以要翻墙喽，如果你没有VPN代理工具，可以去下载Lantern。删除之后立即搜索还是能搜到的，因为有一定的延迟，可能要半个小时才能更新。pod trunk 命令在终端输入1pod trunk --help可以查看帮助使用脚本没必要每次都重复每个步骤，如果你已经发布过一个，可以省去注册的步骤，直接把已经发不过的podspec复制一份，改一下仓库模块名，验证通过就可以发布了。我写了一个便于发布更新的脚本，把脚本放在与podspec同级目录下，当你更新了项目之后，如果需要更新到cocoapods，可以执行此脚本。流程是：1输入版本号 -&gt; commit、push tag -&gt; pod spec lint -&gt; 询问是否发布(y/n) -&gt; 发布(y)脚本的项目在这里：https://github.com/xaoxuu/podspec.sh。"},{"title":"ReactiveCocoa 初探","permalink":"https://xaoxuu.com/blog/2016-07-20-reactive-cocoa/","text":"关于RACRAC是 GitHub开源的ReactiveCocoa框架 。RAC简化代码，使一个功能的代码集中到一起，提高了代码聚合性。 (高内聚，低耦合)安装：1pod 'ReactiveCocoa'导入头文件1#import &lt;ReactiveCocoa/ReactiveCocoa.h&gt;应用场景代替代理（更少代码）1- rac_signalForSelector:代替KVO1- rac_valuesAndChangesForKeyPath:监听事件（用于MVVM）1- rac_signalForControllerEvents:代替通知（自动remove）1- rac_addObserverForName:监听文本框内容改变1- rac_textSignal:处理当界面有多次请求时，需要都获取到数据时，才能展示界面1- rac_liftSelector:WithSignalFromArray:Signals:"},{"title":"git 常用命令以及相关资料","permalink":"https://xaoxuu.com/blog/2016-06-07-git/","text":"相关资料：廖雪峰教程链接Git远程操作详解Git查看、删除、重命名远程分支和tag操作流程日常使用git更新提交代码的一般流程是这样的：在对代码进行了一些修改之后，使用：git add --all将本地所有新增文件添加进版本库。使用：git commit -m 备注将代码提交到本地版本库。（备注内容没有空格的话不需要加引号）使用：git pull origin从服务器拉取代码，更新本地版本库。使用：git push origin将本地版本库推送到服务器。创建创建并切换 branch1git checkout -b 分支名仅仅切换 branch1git checkout 分支名创建 tag1git tag 标签名创建 tag 并备注(备注信息加不加双引号都可以)1git tag -a 标签名 -m 备注信息创建PGP tag 并备注1git tag -s 标签名 -m 备注信息查看查看本地 branch list1git branch 分支名查看远程 branch list1git branch -r 分支名查看所有 branch list1git branch -a 分支名查看本地 tag1git tag查看某个本地 tag 详情1git show 标签名删除删除本地 branch / tag1git branch -d 分支名或标签名删除所有未推送的本地 branch1git fetch -p仅仅删除某个远程 branch / tag123git push origin :分支名或标签名# 或者git push origin --delete 分支名或标签名推送推送某个 branch / tag1git push origin 分支名或标签名推送所有 branch1git push --all origin推送所有 tag1git push --tags重命名重命名本地分支1git branch -m 旧分支名 新分支名重命名远程分支需要分三步操作删除远程分支重命名本地分支推送本地分支回滚soft （默认）只回滚到某个commit，本地代码不变 (不加–soft或–hard默认为–soft)1git reset --soft 分支名或标签名hard彻底回滚（commit和本地代码都回滚）1git reset --hard 分支名或标签名下载、合并分支合并某本地分支到当前分支1git merge 分支名合并某远程分支到当前分支 直接合并，慎用1git pull origin 远程分支名下载某个远程标签1git fetch origin tag 远程标签名"},{"title":"十万蝼蚁不如一个巨人","permalink":"https://xaoxuu.com/blog/2016-05-22-its-better-to-be-a-titan/","text":"混乱不是深渊。混乱是阶梯。很多人想往上爬 却失败了且永无机会再试。他们坠落而亡。有人本有机会攀爬，但他们拒绝了。他们守着王国不放守着诸神守着爱情尽皆幻想。唯有阶梯是真实存在。攀爬才是生活的全部。—— Game of Thrones物竞天择世界是残酷的，强者以弱者为食。个体意识每个人都是一个独立的个体，群众的力量再强大，他们也不属于你，只是在某些时刻能够帮到你。与其成为一个强大群体中微不足道的一员，不如成为一个强大的个体。群体意识社会不需要太多巨人，需要团结在一起才能发挥威力的蚂蚁一族。像牧羊一样，管好头羊，其他都会乖乖跟着头羊，即使有不听话的，也不会威胁到牧羊人。但如果羊羔中有几个或更多比牧羊人掌管的头羊更加强壮的个体，牧羊人就会地位不保。这些羊羔如果足够聪明的话，是不应该过早展露实力的，冲动的结局则是变成一桌美食。珍惜当下活着本来就是如临深渊，如履薄冰，永远不能保证下一刻不会遭遇意外。每天早上睁开眼能够看到熟悉的世界，能够记得自己走过的人生，都值得庆幸。不做别人的棋子，更不教育自己的后代如何做好这一颗棋子，生活是你自己的。时间、效率、实力我一直把时间作为衡量价值的标准，因为只有时间是有限的、平等的。效率则是将时间转化成实力的最关键一步，是靠自己的努力获得的，谁也赠予不了，谁也偷不了。实力则是我的人生观中的价值所在，也是唯一的追求。选择你可以选择随遇而安，只需要一双发现美的眼睛和积极乐观的心态。也可以攀爬，你会发现到处都是陷阱，一步跌落，就是万丈深渊。哪怕你认为现在的处境已经跌落人生谷底，但是事实是前方依然会有更深的陷阱在等着你。我已经做出了我的选择。—— 2016.05.22"},{"title":"macOS10.12 最新版 CocoaPods 的安装及使用","permalink":"https://xaoxuu.com/blog/2016-03-21-cocoapods/","text":"1. 移除现有Ruby默认源1gem sources --remove https://rubygems.org/2. 使用新的源1gem sources -a https://gems.ruby-china.com3. 验证新源是否替换成功1gem sources -l4. 更新gem1sudo gem update --system5. 安装CocoaPods12sudo gem install -n /usr/local/bin cocoapodspod setup6. 新建工程，并在终端用cd指令到文件夹内1pod search 某第三方库7. 新建Podfile文件1vim Podfile写入以下内容并保存：（参考）12345678910platform:ios, '9.0'target '你的项目的target' do pod 'MJRefresh', '~&gt; 3.1.0' pod 'YYKit' pod 'AXKit' pod 'SCLAlertView-Objective-C', '~&gt; 1.0.3' #pod 'MJExtension', '~&gt; 3.0.10' #pod 'SDWebImage', '~&gt; 3.7.6'end小提示：（终端vim文件 按i可编辑 ，esc退出编辑，:wq可保存退出）8. 安装第三方库到项目中1pod install等待安装完成，打开你的项目.xcworkspace即可。n. 更新本地的repo如果第三方库更新了，而本地已有一个旧版本，可以执行pod update以更新。"},{"title":"我理想的智能生活","permalink":"https://xaoxuu.com/blog/2016-02-11-smart-life/","text":"梦想我从小就对”活着“的机械十分着迷，就是我们现在所说的人工智能，当我初次了解到这个概念的时候，就确定了我将奉献一生的事业。然而梦想很遥远，遥远到我这辈子无法见证 《I, Robot》 那样的时代。选择梦想与生活兼得，目前唯一可选的也就智能家居了。我坚信，不久的未来会有越来越多的东西要接入互联网，接入互联网就可以用手机控制。网络就像神经，门窗联了网，门窗就活了，扫把联了网，扫把就活了。等所有的家具家电都联网的时候，就需要一个平台来管理这些智能硬件了。所有接入互联网的传感器都成为了这个智能系统的感官，神经将这些信息传递到可以分析、处理数据的终端，经过计算后作出应答，并由这些神经传递指令到相应的智能设备上。人与人、人与物之间的联系就更加紧密了，实时通话，远程协助都更加方便了。当然，这中间涉及到的隐私和网络安全问题也十分重要，但问题总要解决，不能因噎废食。传统硬件，将一步一步被替换为智能硬件，至少是能用手机app控制，用手机app来控制，就是一种雏形了。毕竟目前没有足够多的智能硬件，没有到需要开发一个系统的程度。平台现在智能硬件也越来越多了，网络也十分发达了，但是它们的”语言“不同，各厂商的产品都用自己的标准，不同厂商之间的硬件是无法协同工作的。它们需要一个协议、或者一个平台，来实现合作。平台，也许就是智能家居时代来临的一个必要条件吧。"}]}